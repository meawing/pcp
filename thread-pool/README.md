# Thread pool

Реализуйте пул потоков. Используйте библиотеку `lines`.

## Потоки

При старте пула запускается `num_threads` потоков. До разрушения пула количество потоков не изменяется.

## Submit

Метод `void Submit(Task task)` позволяет запланировать задачу на исполнение в одном из потоков пула. Передача объекта `Task` из потока планирующего задачу в поток пула происходит через `MPMCBlockingUnboundedQueue`, т.к. потоки могут конкурентно планировать задачи на исполнение. Сам метод `Submit` лишь отправляет задачу в очередь и не дожидается её выполнения.

## Wait

Перед разрушением пула потоков требуется вызвать метод `void Wait()`. Все вызванные до этого задачи обязаны завершиться до выхода из метода `Wait`. Задачи запланированные после завершения вызова `Wait` не будут исполнены, засчет того, что `Wait` закрывает очередь задач через метод очереди `void Close()`. Для подсчета количества задач в пуле и синхронизации требуемой в `Wait` будем использовать `WaitGroup`. 

## WaitGroup

`WaitGroup` -  некоторый счетчик работы. `void Add(count)` способ увеличить счётчик на `count` единиц. `void Done()` уменьшить счетчик работы на `1`. `void Wait()` - способ дождаться момента, когда счетчик работы опустится до нуля. Т.е. поток, вызвавщий метод `Wait`, засыпает до обнуления счетчика работы (при этом такая ситуация по семантике возникает лишь один раз).

## This

У пула потоков есть статический метод, позволяющий вернуть указатель на `ThreadPool`, в котором исполняется текущий код. В случае, если мы находимся вне пула, `ThreadPool::This()` возвращает `nullptr`. Для реализации нужно использовать глобальную переменную `static thread_local lines::ThreadLocalPtr`.
